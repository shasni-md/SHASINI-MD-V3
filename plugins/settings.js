const { cmd, commands } = require('../lib/command')
const config = require('../config')
var { get_set , input_set } = require('../lib/set_db') 
const { getBuffer, getGroupAdmins, getRandom, h2k, isUrl, Json, runtime, sleep, fetchJson, jsonformat} = require('../lib/functions')

cmd({
    pattern: "heartreact",
    react: "üó£Ô∏è",
    desc: "",
    category: "",
    use: '.heartreact on/off',
    filename: __filename
},    
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply , config}) => {
try{
if (!isOwner) return reply("‚ùå You are not the owner!");	
if (q == 'on') {
  if ( config.HEART_REACT == 'true') return reply('already on ')
  await input_set('HEART_REACT' , 'true')
  return reply('heartreact turned on')
  }
if ( q == 'off' ) {
   if ( config.HEART_REACT !== 'true') return reply('already off')
  await input_set('HEART_REACT' , 'false')
  return reply('heartreact turned off')
}
  
} catch (e) {
reply('*Error !!*')
l(e)
}
})


cmd({
    pattern: "autovoice",
    react: "üó£Ô∏è",
    desc: "",
    category: "",
    use: '.autovoice on/off',
    filename: __filename
},    
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply , config}) => {
try{
if (!isOwner) return reply("‚ùå You are not the owner!");	
if (q == 'on') {
  if ( config.AUTO_VOICE == 'true') return reply('already on ')
  await input_set('AUTO_VOICE' , 'true')
  return reply('autovoice turned on')
  }
if ( q == 'off' ) {
   if ( config.AUTO_VOICE !== 'true') return reply('already off')
  await input_set('AUTO_VOICE' , 'false')
  return reply('autovoice turned off')
}
  
} catch (e) {
reply('*Error !!*')
l(e)
}
})


cmd({
    pattern: "autosticker",
    react: "üó£Ô∏è",
    desc: "",
    category: "",
    use: '.autosticmer on/off',
    filename: __filename
},    
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply , config}) => {
try{
if (!isOwner) return reply("‚ùå You are not the owner!");	
if (q == 'on') {
  if ( config.AUTO_STICKER == 'true') return reply('already on ')
  await input_set('AUTO_STICKER' , 'true')
  return reply('autosticker turned on')
  }
if ( q == 'off' ) {
   if ( config.AUTO_STICKER !== 'true') return reply('already off')
  await input_set('AUTO_STICKER' , 'false')
  return reply('autosticker turned off')
}
  
} catch (e) {
reply('*Error !!*')
l(e)
}
})


cmd({
    pattern: "autobio",
    react: "üó£Ô∏è",
    desc: "",
    category: "",
    use: '.autobio on/off',
    filename: __filename
},    
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply , config}) => {
try{
if (!isOwner) return reply("‚ùå You are not the owner!");	
if (q == 'on') {
  if ( config.AUTO_BIO == 'true') return reply('already on ')
  await input_set('AUTO_BIO' , 'true')
  return reply('autobio turned on')
  }
if ( q == 'off' ) {
   if ( config.AUTO_BIO !== 'true') return reply('already off')
  await input_set('AUTO_BIO' , 'false')
  return reply('autobio turned off')
}
  
} catch (e) {
reply('*Error !!*')
l(e)
}
})

cmd({
    pattern: "autowelcome",
    react: "üó£Ô∏è",
    desc: "",
    category: "",
    use: '.autowelcome on/off',
    filename: __filename
},    
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply , config}) => {
try{
if (!isOwner) return reply("‚ùå You are not the owner!");	
if (q == 'on') {
  if ( config.AUTO_WELCOME == 'true') return reply('already on ')
  await input_set('AUTO_WELCOME' , 'true')
  return reply('autowelcome turned on')
  }
if ( q == 'off' ) {
   if ( config.AUTO_WELCOME !== 'true') return reply('already off')
  await input_set('AUTO_WELCOME' , 'false')
  return reply('autowelcome turned off')
}
  
} catch (e) {
reply('*Error !!*')
l(e)
}
})

cmd({
    pattern: "antibot",
    react: "üó£Ô∏è",
    desc: "",
    category: "",
    use: '.antibot on/off',
    filename: __filename
},    
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply , config}) => {
try{
if (!isOwner) return reply("‚ùå You are not the owner!");	
if (q == 'on') {
  if ( config.ANTI_BOT == 'true') return reply('already on ')
  await input_set('ANTI_BOT' , 'true')
  return reply('antibot turned on')
  }
if ( q == 'off' ) {
   if ( config.ANTI_BOT !== 'true') return reply('already off')
  await input_set('ANTI_BOT' , 'false')
  return reply('antibot turned off')
}
  
} catch (e) {
reply('*Error !!*')
l(e)
}
})

cmd({
    pattern: "antilink",
    react: "üó£Ô∏è",
    desc: "",
    category: "",
    use: '.antilink on/off',
    filename: __filename
},    
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply , config}) => {
try{
if (!isOwner) return reply("‚ùå You are not the owner!");	
if (q == 'on') {
  if ( config.ANTI_LINK == 'true') return reply('already on ')
  await input_set('ANTI_LINK' , 'true')
  return reply('antilink turned on')
  }
if ( q == 'off' ) {
   if ( config.ANTI_LINK !== 'true') return reply('already off')
  await input_set('ANTI_LINK' , 'false')
  return reply('antilink turned off')
}
  
} catch (e) {
reply('*Error !!*')
l(e)
}
})

	  
cmd({
    pattern: "antibad",
    react: "üó£Ô∏è",
    desc: "",
    category: "",
    use: '.antibad on/off',
    filename: __filename
},    
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply , config}) => {
try{
if (!isOwner) return reply("‚ùå You are not the owner!");
if (q == 'on') {
  if ( config.ANTI_BAD == 'true') return reply('already on ')
  await input_set('ANTI_BAD' , 'true')
  return reply('antibad turned on')
  }
if ( q == 'off' ) {
   if ( config.ANTI_BAD !== 'true') return reply('already off')
  await input_set('ANTI_BAD' , 'false')
  return reply('antibad turned off')
}
  
} catch (e) {
reply('*Error !!*')
l(e)
}
})	


cmd({
    pattern: "autostatus",
    react: "üó£Ô∏è",
    desc: "",
    category: "",
    use: '.autostatus on/off',
    filename: __filename
},    
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply , config}) => {
try{
if (!isOwner) return reply("‚ùå You are not the owner!");	
if (q == 'on') {
  if ( config.AUTO_READ_STATUS == 'true') return reply('already on ')
  await input_set('AUTO_READ_STATUS' , 'true')
  return reply('autostatus turned on')
  }
if ( q == 'off' ) {
   if ( config.AUTO_READ_STATUS !== 'true') return reply('already off')
  await input_set('AUTO_READ_STATUS' , 'false')
  return reply('autostatus turned off')
}
  
} catch (e) {
reply('*Error !!*')
l(e)
}
})

cmd({
    pattern: "autotyping",
    react: "üó£Ô∏è",
    desc: "",
    category: "",
    use: '.autotyping on/off',
    filename: __filename
},    
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply , config}) => {
try{
if (!isOwner) return reply("‚ùå You are not the owner!");	
if (q == 'on') {
  if ( config.AUTO_TYPING == 'true') return reply('already on ')
  await input_set('AUTO_TYPING' , 'true')
  return reply('autotyping turned on')
  }
if ( q == 'off' ) {
   if ( config.AUTO_TYPING !== 'true') return reply('already off')
  await input_set('AUTO_TYPING' , 'false')
  return reply('autotyping turned off')
}
  
} catch (e) {
reply('*Error !!*')
l(e)
}
})	

cmd({
    pattern: "autorecording",
    react: "üó£Ô∏è",
    desc: "",
    category: "",
    use: '.autorecording on/off',
    filename: __filename
},    
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply , config}) => {
try{
if (!isOwner) return reply("‚ùå You are not the owner!");	
if (q == 'on') {
  if ( config.RECORDING == 'true') return reply('already on ')
  await input_set('RECORDING' , 'true')
  return reply('autorecording turned on')
  }
if ( q == 'off' ) {
   if ( config.RECORDING !== 'true') return reply('already off')
  await input_set('RECORDING' , 'false')
  return reply('autorecording turned off')
}
  
} catch (e) {
reply('*Error !!*')
l(e)
}
})	

cmd({
    pattern: "cmdread",
    react: "üó£Ô∏è",
    desc: "",
    category: "",
    use: '.autotyping on/off',
    filename: __filename
},    
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply , config}) => {
try{
if (!isOwner) return reply("‚ùå You are not the owner!");	
if (q == 'on') {
  if ( config.READ_CMD == 'true') return reply('already on ')
  await input_set('READ_CMD' , 'true')
  return reply('cmd turned on')
  }
if ( q == 'off' ) {
   if ( config.READ_CMD !== 'true') return reply('already off')
  await input_set('READ_CMD' , 'false')
  return reply('cmdread turned off')
}
  
} catch (e) {
reply('*Error !!*')
l(e)
}
})	

cmd({
    pattern: "autoreact",
    react: "üó£Ô∏è",
    desc: "",
    category: "",
    use: '.autoreact on/off',
    filename: __filename
},    
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply , config}) => {
try{
if (!isOwner) return reply("‚ùå You are not the owner!");
if (q == 'on') {
  if ( config.AUTO_REACT == 'true') return reply('already on ')
  await input_set('AUTO_REACT' , 'true')
  return reply('autoreact turned on')
  }
if ( q == 'off' ) {
   if ( config.AUTO_REACT !== 'true') return reply('already off')
  await input_set('AUTO_REACT' , 'false')
  return reply('autoreact turned off')
}
  
} catch (e) {
reply('*Error !!*')
l(e)
}
})	



cmd({
    pattern: "alwaysonline",
    react: "üó£Ô∏è",
    desc: "",
    category: "",
    use: '.alwaysonline on/off',
    filename: __filename
},    
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply , config}) => {
try{
if (!isOwner) return reply("‚ùå You are not the owner!");	
if (q == 'on') {
  if ( config.ALWAYS_ONLINE == 'true') return reply('already on ')
  await input_set('ALWAYS_ONLINE' , 'true')
  return reply('alwaysonline turned on')
  }
if ( q == 'off' ) {
   if ( config.ALWAYS_ONLINE !== 'true') return reply('already off')
  await input_set('ALWAYS_ONLINE' , 'false')
  return reply('alwaysonline turned off')
}
  
} catch (e) {
reply('*Error !!*')
l(e)
}
})	

cmd({
    pattern: "212block",
    react: "üó£Ô∏è",
    desc: "",
    category: "",
    use: '.212block on/off',
    filename: __filename
},    
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply , config}) => {
try{
if (!isOwner) return reply("‚ùå You are not the owner!");	
if (q == 'on') {
  if ( config.NUMBER_212_BLOCK == 'true') return reply('already on ')
  await input_set('NUMBER_212_BLOCK' , 'true')
  return reply('212block turned on')
  }
if ( q == 'off' ) {
   if ( config.NUMBER_212_BLOCK !== 'true') return reply('already off')
  await input_set('NUMBER_212_BLOCK' , 'false')
  return reply('212block turned off')
}
  
} catch (e) {
reply('*Error !!*')
l(e)
}
})

cmd({
    pattern: "anticall",
    react: "üó£Ô∏è",
    desc: "",
    category: "",
    use: '.anticall on/off',
    filename: __filename
},    
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply , config}) => {
try{
if (!isOwner) return reply("‚ùå You are not the owner!");	
if (q == 'on') {
  if ( config.ANTI_CALL == 'true') return reply('already on ')
  await input_set('ANTI_CALL' , 'true')
  return reply('anticall turned on')
  }
if ( q == 'off' ) {
   if ( config.ANTI_CALL !== 'true') return reply('already off')
  await input_set('ANTI_CALL' , 'false')
  return reply('anticall turned off')
}
  
} catch (e) {
reply('*Error !!*')
l(e)
}
})

cmd({
    pattern: "antidelete",
    react: "üó£Ô∏è",
    desc: "",
    category: "",
    use: '.antidelete on/off',
    filename: __filename
},    
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply , config}) => {
try{
if (!isOwner) return reply("‚ùå You are not the owner!");	
if (q == 'on') {
  if ( config.ANTI_DELETE == 'true') return reply('already on ')
  await input_set('ANTI_DELETE' , 'true')
  return reply('antidelete turned on')
  }
if ( q == 'off' ) {
   if ( config.ANTI_DELETE !== 'true') return reply('already off')
  await input_set('ANTI_DELETE' , 'false')
  return reply('antidelete turned off')
}
  
} catch (e) {
reply('*Error !!*')
l(e)
}
})

cmd({
    pattern: "antidelete",
    react: "üó£Ô∏è",
    desc: "",
    category: "",
    use: '.antidelete on/off',
    filename: __filename
},    
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply , config}) => {
try{
if (!isOwner) return reply("‚ùå You are not the owner!");	
if (q == 'on') {
  if ( config.ANTI_DELETE == 'true') return reply('already on ')
  await input_set('ANTI_DELETE' , 'true')
  return reply('antidelete turned on')
  }
if ( q == 'off' ) {
   if ( config.ANTI_DELETE !== 'true') return reply('already off')
  await input_set('ANTI_DELETE' , 'false')
  return reply('antidelete turned off')
}
  
} catch (e) {
reply('*Error !!*')
l(e)
}
})

cmd({
    pattern: "aichat",
    react: "üó£Ô∏è",
    desc: "",
    category: "",
    use: '.aichat on/off',
    filename: __filename
},    
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply , config}) => {
try{
if (!isOwner) return reply("‚ùå You are not the owner!");	
if (q == 'on') {
  if ( config.AI_CHAT == 'true') return reply('already on ')
  await input_set('AI_CHAT' , 'true')
  return reply('aichat turned on')
  }
if ( q == 'off' ) {
   if ( config.AI_CHAT !== 'true') return reply('already off')
  await input_set('AI_CHAT' , 'false')
  return reply('aichat turned off')
}
  
} catch (e) {
reply('*Error !!*')
l(e)
}
})

cmd({
    pattern: "autosongsend",
    react: "üó£Ô∏è",
    desc: "",
    category: "",
    use: '.autosongsend on/off',
    filename: __filename
},    
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply , config}) => {
try{
if (!isOwner) return reply("‚ùå You are not the owner!");	
if (q == 'on') {
  if ( config.AUTO_SONG_SENDER == 'true') return reply('already on ')
  await input_set('AUTO_SONG_SENDER' , 'true')
  return reply('autosongsend turned on')
  }
if ( config.AUTO_SONG_SENDER !== 'true') return reply('already off')
  await input_set('AUTO_SONG_SENDER' , 'false')
  return reply('autosongsend turned off')
}
  
} catch (e) {
reply('*Error !!*')
l(e)
}
})


cmd({
    pattern: "mode",
    react: "üó£Ô∏è",
    desc: "",
    category: "",
    use: '.mode public/private',
    filename: __filename
},    
async(conn, mek, m,{from, prefix, l, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply , config}) => {
try{
if (!isOwner) return reply("‚ùå You are not the owner!");		
if (q == 'private') {
  if ( config.MODE == 'private') return reply('already private ')
  await input_set('MODE' , 'private')
  return reply('private mode turned on')
  }
if ( q == 'public' ) {
   if ( config.MODE !== 'public') return reply('already public')
  await input_set('MODE' , 'public')
  return reply('public mode turned off')
}
if ( q == 'inbox' ) {
   if ( config.MODE !== 'inbox') return reply('already inbox')
  await input_set('MODE' , 'inbox')
  return reply('inbox mode turned off')
}
if ( q == 'groups' ) {
   if ( config.MODE !== 'groups') return reply('already groups')
  await input_set('MODE' , 'groups')
  return reply('groups mode turned off')
}
  
} catch (e) {
reply('*Error !!*')
l(e)
}
})

cmd({
    pattern: "settings",
    react: "üó£Ô∏è",
    alias: ["setting"],
    desc: "Check bot online or not.",
    category: "main",
    filename: __filename
}, 
async (conn, mek, m, { from, quoted, body, isCmd, command, args, q, isGroup, sender, senderNumber, botNumber2, botNumber, pushname, isMe, isOwner, groupMetadata, groupName, participants, groupAdmins, isBotAdmins, isAdmins, reply }) => {
    try {
        if (!isOwner) return;

        const vv = await conn.sendMessage(from, {
            image: { url: 'https://files.catbox.moe/za6ytm.jpg' },
            caption: `*[ ‚Ä¢  DIDULA-MD-V2 - SETTINGS‚Äé ‚Ä¢ ]*
*‚ï≠‚îà‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Ä¢*
*‚îä* *‚ôæÔ∏è AUTO_READ_STATUS:* ‚û† ${config.AUTO_READ_STATUS}
*‚îä* *‚ôæÔ∏è MODE:* ‚û† ${config.MODE} 
*‚îä* *‚ôæÔ∏è AI_CHAT:* ‚û† ${config.AI_CHAT} 
*‚îä* *‚ôæÔ∏è ANTI_DELETE:* ‚û† ${config.ANTI_DELETE} 
*‚îä* *‚ôæÔ∏è AUTO_VOICE:* ‚û† ${config.AUTO_VOICE} 
*‚îä* *‚ôæÔ∏è AUTO_STICKER:* ‚û† ${config.AUTO_STICKER} 
*‚îä* *‚ôæÔ∏è ALIVE_IMG:* ‚û† ${config.ALIVE_IMG
*‚îä* *‚ôæÔ∏è ALIVE_MSG:* ‚û† ${config.ALIVE_MSG}  
*‚îä* *‚ôæÔ∏è SUDO:* ‚û† ${config.SUDO}
*‚îä* *‚ôæÔ∏è ANTI_LINK:* ‚û† ${config.ANTI_LINK}
*‚îä* *‚ôæÔ∏è ANTI_CALL:* ‚û† ${config.ANTI_CALL} 
*‚îä* *‚ôæÔ∏è ANTI_BAD:* ‚û† ${config.ANTI_BAD} 
*‚îä* *‚ôæÔ∏è PREFIX:* ‚û† [${config.PREFIX}]
*‚îä* *‚ôæÔ∏è AUTO_RECORDING:* ‚û† ${config.RECORDING} 
*‚îä* *‚ôæÔ∏è HEART_REACT:* ‚û† ${config.HEART_REACT} 
*‚îä* *‚ôæÔ∏è FOOTER:* ‚û† ${config.FOOTER}
*‚îä* *‚ôæÔ∏è AUTO_SONG_SENDER:* ‚û† ${config.AUTO_SONG_SENDER} 
*‚îä* *‚ôæÔ∏è CMD_READ:* ‚û† ${config.READ_CMD}
*‚ï∞‚îà‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Ä¢*
‚îè‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îì
‚îÉ      üîó  *CUSTOMIZE YOUR SETTINGS* ‚§µÔ∏è
‚îó‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îõ

‚îè‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îì
‚îÉ       üîß *OPTIONS MENU* üîß
‚îÉ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÉ

‚î£‚îÅ *_WORK MODE_* ‚§µÔ∏è
‚îÉ   ‚î£ 1.1 üîπ *Public Work*
‚îÉ   ‚î£ 1.2 üîπ *Private Work*
‚îÉ   ‚î£ 1.3 üîπ *Groups Only*
‚îÉ   ‚îó 1.4 üîπ *Inbox Only*

‚î£‚îÅ *_AUTO VOICE_* ‚§µÔ∏è
‚îÉ   ‚î£ 2.1 üîä *Auto Voice On*
‚îÉ   ‚îó 2.2 üîï *Auto Voice Off*

‚î£‚îÅ *_AUTO STATUS SEEN_* ‚§µÔ∏è
‚îÉ   ‚î£ 3.1 üëÅÔ∏è‚Äçüó®Ô∏è *Auto Read Status On*
‚îÉ   ‚îó 3.2 üëÅÔ∏è‚ùå *Auto Read Status Off*

‚î£‚îÅ *_AUTO BIO_* ‚§µÔ∏è
‚îÉ   ‚î£ 4.1 ‚úçÔ∏è *Auto Bio On*
‚îÉ   ‚îó 4.2 ‚úçÔ∏è‚ùå *Auto Bio Off*

‚î£‚îÅ *_AUTO TYPING_* ‚§µÔ∏è
‚îÉ   ‚î£ 5.1 üìù *Activate Auto Typing*
‚îÉ   ‚îó 5.2 üìù‚ùå *Deactivate Auto Typing*

‚î£‚îÅ *_AUTO COMMAND READ_* ‚§µÔ∏è
‚îÉ   ‚î£ 6.1 üñäÔ∏è *Activate Auto Command Read*
‚îÉ   ‚îó 6.2 üñäÔ∏è‚ùå *Deactivate Auto Command Read*

‚î£‚îÅ *_ANTI CALL_* ‚§µÔ∏è
‚îÉ   ‚î£ 7.1 üîä *Anti Call On*
‚îÉ   ‚îó 7.2 üîï *Anti Call Off*

‚î£‚îÅ *_HEART REACT_* ‚§µÔ∏è
‚îÉ   ‚î£ 8.1 ‚úçÔ∏è *Heart React On*
‚îÉ   ‚îó 8.2 ‚úçÔ∏è‚ùå *Heart React Off*

‚î£‚îÅ *_ANTI DELETE_* ‚§µÔ∏è
‚îÉ   ‚î£ 9.1 üìù *Activate Anti Delete*
‚îÉ   ‚îó 9.2 üìù‚ùå *Deactivate Anti Delete*

‚î£‚îÅ *_AUTO STICKER_* ‚§µÔ∏è
‚îÉ   ‚î£ 10.1 üëÅÔ∏è‚Äçüó®Ô∏è *Auto Sticker On*
‚îÉ   ‚îó 10.2 üëÅÔ∏è‚ùå *Auto Sticker Off*

‚î£‚îÅ *_AI CHAT* ‚§µÔ∏è
‚îÉ   ‚î£ 11.1 üìù *Activate Ai Chat*
‚îÉ   ‚îó 11.2 üìù‚ùå *Deactivate Ai Chat*

‚î£‚îÅ *_ANTI LINK_* ‚§µÔ∏è
‚îÉ   ‚î£ 12.1 üñäÔ∏è *Activate Anti Link*
‚îÉ   ‚îó 12.2 üñäÔ∏è‚ùå *Deactivate Anti Link*

‚î£‚îÅ *_ANTI BAD_* ‚§µÔ∏è
‚îÉ   ‚î£ 13.1 üëÅÔ∏è‚Äçüó®Ô∏è *Anti Bad On*
‚îÉ   ‚îó 13.2 üëÅÔ∏è‚ùå *Anti Bad Off*

‚î£‚îÅ *_AUTO RECORDING_* ‚§µÔ∏è
‚îÉ   ‚î£ 14.1 üîä *Auto Recording On*
‚îÉ   ‚îó 14.2 üîï *Auto Recording Off*

‚î£‚îÅ *_AUTO SONG SENDER_* ‚§µÔ∏è
‚îÉ   ‚î£ 15.1 üëÅÔ∏è‚Äçüó®Ô∏è *Auto Song Sender On*
‚îÉ   ‚îó 15.2 üëÅÔ∏è‚ùå *Auto Song Sender Off*
‚îó‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îõ

> *¬©·¥ò·¥è·¥°·¥á Ä·¥á·¥Ö  ô è DIDULA*
`
        }, { quoted: mek });

        conn.ev.on('messages.upsert', async (msgUpdate) => {
            const msg = msgUpdate.messages[0];
            if (!msg.message || !msg.message.extendedTextMessage) return;

            const selectedOption = msg.message.extendedTextMessage.text.trim();

            if (msg.message.extendedTextMessage.contextInfo && msg.message.extendedTextMessage.contextInfo.stanzaId === vv.key.id) {
                switch (selectedOption) {
                    case '1.1':
                        reply(".mode public" );
                        reply(".restart");
                        break;
                    case '1.2':               
                        reply(".mode private");
                        reply(".restart");
                        break;
                    case '1.3':               
                          reply(".mode groups");
                        reply(".restart");
                      break;
                    case '1.4':     
                        reply(".mode inbox");
                        reply(".restart");
                      break;
                    case '2.1':     
                        reply("autovoice on");
                        reply(".restart");
                        break;
                    case '2.2':     
                        reply(".autovoice off");
                        reply(".restart");
                    break;
                    case '3.1':    
                        reply(".autostatus on");
                        reply(".restart");
                    break;
                    case '3.2':    
                        reply(".autostatus off");
                        reply(".restart");
                    break;
                    case '4.1': 
                    reply(".autobio on");
                    reply(".restart");
                    break;
                    case '4.2': 
                    reply(".autobio off");
                    reply(".restart");
                    break;
                    case '5.1':      
                        reply(".autotyping on");
                        reply(".restart");
                        break;
                    case '5.2':   
                        reply(".autotyping off");
                        reply(".restart");
                    break;
                    case '6.1': 
                        reply(".cmdread on");
                        reply(".restart");
                    break;
                    case '6.2':   
                        reply(".cmdread off");
                        reply(".restart");
                    break;
                    case '7.1': 
                        reply(".anticall on");
                        reply(".restart");
                    break;
                    case '7.2':   
                        reply(".anticall off");
                        reply(".restart");
                        break;
                    case '8.1': 
                        reply(".heartreact on");
                        reply(".restart");
                    break;
                    case '8.2':   
                        reply(".heartreact off");
                        reply(".restart");
                        break;
                    case '9.1': 
                        reply(".antidelete on");
                        reply(".restart");
                    break;
                    case '9.2':   
                        reply(".antidelete off");
                        reply(".restart");
                        break;
                    case '10.1': 
                        reply(".autosticker on");
                        reply(".restart");
                    break;
                    case '10.2':   
                        reply(".autosticker off");
                        reply(".restart");
                        break;
                    case '11.1': 
                        reply(".aichat on");
                        reply(".restart");
                    break;
                    case '11.2':   
                        reply(".aichat off");
                        reply(".restart");
                        break;
                    case '12.1': 
                        reply(".antilink on");
                        reply(".restart");
                    break;
                    case '12.2':   
                        reply(".antilink off");
                        reply(".restart");
                        break;
                    case '13.1': 
                        reply(".antibad on");
                        reply(".restart");
                    break;
                    case '13.2':   
                        reply(".antibad off");
                        reply(".restart");
                        break;
                    case '14.1': 
                        reply(".autorecording on");
                        reply(".restart");
                    break;
                    case '14.2':   
                        reply(".autorecording off");
                        reply(".restart");
                        break;
                    case '15.1': 
                        reply(".autosongsend on");
                        reply(".restart");
                    break;
                    case '15.2':   
                        reply(".autosongsend off");
                        reply(".restart");
                    
                        break;
                    default:
                        reply("Invalid option. Please select a valid optionüî¥");
                }

            }
        });

    } catch (e) {
        console.error(e);
        await conn.sendMessage(from, { react: { text: '‚ùå', key: mek.key } })
        reply('An error occurred while processing your request.');
    }
});